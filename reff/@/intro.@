// intro.@
// これでコメント。
"sysbio.@h" include // sysbioはSYStem Basic Input/Output

intro mdl // Javaのクラス的なのを採用
	[args] main @public
	@begin
		// 動的型付け言語。

		demo @public <- 32
		// mdl内変数ではpublicを省略時はprivate。

		"Hello, world!", newl @sys:txout
		demo, newl @sys:txout

		demo2 <- 16
		List$ls <- [demo, demo2] @intro:moreFunction // リストは変数に$をつけた後にlsと指定する。これはプロパティ構文という構文である。

		i <- 0, k <- 0; i++ , k++; for < 10 , < 5 // これなら二重ループ。iが速く動き、iが条件を満たしたらkが動いてiが初期値に戻る。
		@begin
			"i: ", i, newl, "k: ", k, newl @sys:txout
		@end

		s1 str <- @sys:txin
		@sys:txin.fail if // @xx:yy.zzはメンバ関数。
		@begin
			"Invalid input", newl @sys:txout // ちなみに@sys:txout.noflushにするとバッファフラッシュをしないでおいておくこともできる。デフォルトは呼び出すとフラッシュされるようになっている。
			"ERROR_INPUT_STR_INVALID" errno // errnoはretと排他の関係にある構文で、他言語でいう例外処理的な扱いになる。errnoは上位でキャッチできる構造(エラーコード数値でもエラーコード文字列でも)を返す必要がある。errnoは上位でhitすることをすることで処理でき、
				// その処理が終わったら元のerrnoの次の行から再開する(back)かそのcatchしたところと同じ関数で再送する(ret)かerrnoの起こった行を再送する(rtry)かプロセスをキルする(die)必要がある。
		@end

		0 ret // return。関数の方に合わせたものを返す必要がある。
	@end

	[args] moreFunction$ls @private // プロパティ構文は関数定義、宣言でも同様。
	@begin
		tmp <- [args, 0] @sys:getarg // こうなるのかなぁ・・・？わからん。
		tmp2 <- [args, 1] @sys:getarg
		tmp <- tmp + tmp2 // <-は代入記号
		tmp2 <- tmp - tmp2
		tmp <- tmp - tmp2

		[tmp, tmp2] ret // 複数返り値をどう処理するかなぁ。要検討。
	@end
