' intro.@
' これでコメント。
"sysbio.@h" include ' sysbioはSYStem Basic Input/Output

intro mdl ' Javaのクラス的なのを採用
@begin
	[args args] main int @public
	@begin
		demo int @public <- 32
		' mdl内変数ではpublicを省略時はprivate。

		"Hello, world!", newl @sys:txout
		demo ~str, newl @sys:txout // ~は型変換演算子

		demo2 int <- 16
		List$ls int <- [demo, demo2] @intro:moreFunction ' リストは変数に$をつけた後にlsと指定する。これはプロパティ構文という構文である。

		i int <- 0, k int <- 0; i++ , k++; for < 10 , < 5 ' これなら二重ループ。iが速く動き、iが条件を満たしたらkが動いてiが初期値に戻る。
		@begin
			"i: ", i, newl, "k: ", k, newl @sys:txout
		@end

		s1 str <- @sys:txin
		@sys:txin.fail if ' @xx:yy.zzはメンバ関数。
		@begin
			"Invalid input", newl @sys:txout ' ちなみに@sys:txout.noflushにするとバッファフラッシュをしないでおいておくこともできる。デフォルトは呼び出すとフラッシュされるようになっている。
			"ERROR_INPUT_STR_INVALID" errno
			>>?
				errnoはretと排他の関係にある構文で、他言語でいう例外処理的な扱いになる。
				errnoは上位でキャッチできる構造(エラーコード数値でもエラーコード文字列でも)を返す必要がある。
				errnoは上位でhitすることをすることで処理でき、その処理が終わったら
					元のerrnoの次の行から再開する(back)か
					そのcatchしたところと同じ関数で再送する(ret)か
					errnoの起こった行を再送する(rtry)か
					プロセスをキルする(die)
				必要がある。
			?<<
		@end

		0 ret ' return。
	@end

	[args arg] moreFunction$ls int @private ' プロパティ構文は関数定義、宣言でも同様。
	@begin
		tmp int <- [args, 0] @sys:getarg ' こうなるのかなぁ・・・？わからん。
		tmp2 int <- [args, 1] @sys:getarg
		tmp <- tmp + tmp2 ' <-は代入記号
		tmp2 <- tmp - tmp2
		tmp <- tmp - tmp2

		[tmp, tmp2] ret ' 複数返り値をどう処理するかなぁ。要検討。
	@end
@end
