# intro.@
# これでコメント。
>>? 後述の方法で
    複数行コメントも
    当然できる。
?<<

include 'sysbio.@h" # sysbioはSYStem Basic Input/Output

mdl intro # Javaのクラス的なのを採用
@begin
	int main args ag @public
	@begin
		int demo @public <- 32
		# mdl内変数ではpublicを省略時はprivate。

		@sys:txout 'Hello, world!", newl # さすがにわかると思うけど文字列はシングルクォーテーションから始まりダブルクォーテーションで終わる、
										 # 文字列の中で文字列を扱うような入れ子が可能になる方式。
										 # なんでかって？そりゃ、日本語で言う鍵括弧のように方向性のある括弧を使うためにそう割り当ててるからだよ
										 # 勿論これの中でダブルクォーテーションを使いたいときは%でエスケープする必要はあるけど、's1's2"s3"っていう風に書いてもエラーにはならない利点あり
		@sys:txout demo ~str, newl # ~は型変換演算子

		int demo2 <- 16
		int List$ls <- @intro:moreFunction demo, demo2 # リストは変数に$をつけた後にlsと指定する。これはプロパティ構文という構文である。

		int i <- 0 and int k <- 0 -> i++ next k++ -> for i < 10 and k < 5 # これなら二重ループ。iが速く動き、iが条件を満たしたらkが動いてiが初期値に戻る。
		@begin
			@sys:txout 'i: ", i, newl, 'k: ", k, newl
		@end

		str s1;errno <- @sys:txin # errnoを使いたいときは後述のrtry用にこれをつける必要あり
		s1.fail if # @xx:yy.zzやxx.yyはメンバ関数。
		@begin
			@sys:txout @sys:txout 'Invalid input", newl # ちなみに@sys:txout.noflushにするとバッファフラッシュをしないでおいておくこともできる。デフォルトは呼び出すとフラッシュされるようになっている。
			errno 'ERROR_INPUT_STR_INVALID"
			>>?	(先に謝っとく。コメント長いから飛ばしてもいいよ)
				errnoはretと排他の関係にある構文で、他言語でいう例外処理的な扱いになる。
				errnoは上位でキャッチできる構造(エラーコード数値でもエラーコード文字列でも)を返す必要がある。
				errnoは上位でhitすることをすることで処理でき、その処理が終わったら
					元のerrnoの次の行から再開する(back)か
					そのcatchしたところと同じ関数で再送する(ret)か
					errnoの起こった行を再送する(rtry)か
					プロセスをキルする(die)
				必要がある。
			?<<
		@end

		ret 0 # return。
	@end

	int moreFunction$ls args ag @private # プロパティ構文は関数定義、宣言でも同様。
	@begin
		int tmp <- @sys:getarg ag, 0 # こうなるのかなぁ・・・？わからん。
		int tmp2 <- @sys:getarg ag, 1 # ただこれならいろいろ便利っちゃ便利ではあるかなぁ。存在しない引数を受け取る可能性はあれど、
									  # 呼び出し側で@xx:yy ,ag2みたいに書くことでデフォルト引数みたいなこともできないことはないからなぁ

		tmp <- tmp ? tmp2 # <-は代入記号
		tmp2 <- tmp ? tmp2 # ?はXOR演算子
		tmp <- tmp ? tmp2

		ret tmp, tmp2 # 複数返り値をどう処理するかなぁ。要検討。
	@end
@end
