# intro.@
# これでコメント。
include 'sysbio.@h" # sysbioはSYStem Basic Input/Output

mdl intro # Javaのクラス的なのを採用
@begin
	int main args ag @public
	@begin
		int demo @public <- 32
		# mdl内変数ではpublicを省略時はprivate。

		@sys:txout 'Hello, world!", newl # さすがにわかると思うけど文字列はシングルクォーテーションから始まりダブルクォーテーションで終わる、文字列の中で文字列を扱うような入れ子が可能になる方式。
		@sys:txout demo ~str, newl # ~は型変換演算子

		int demo2 <- 16
		int List$ls <- @intro:moreFunction demo, demo2 # リストは変数に$をつけた後にlsと指定する。これはプロパティ構文という構文である。

		int i <- 0 and k <- 0, i++ next k++, for < 10 and < 5 # これなら二重ループ。iが速く動き、iが条件を満たしたらkが動いてiが初期値に戻る。
		@begin
			@sys:txout 'i: ", i, newl, 'k: ", k, newl
		@end

		str s1 <- @sys:txin;errno # errnoを使いたいときは後述のrtry用にこれをつける必要あり
		@sys:txin.fail if # @xx:yy.zzはメンバ関数。
		@begin
			@sys:txout @sys:txout 'Invalid input", newl # ちなみに@sys:txout.noflushにするとバッファフラッシュをしないでおいておくこともできる。デフォルトは呼び出すとフラッシュされるようになっている。
			errno 'ERROR_INPUT_STR_INVALID"
			>>?
				errnoはretと排他の関係にある構文で、他言語でいう例外処理的な扱いになる。
				errnoは上位でキャッチできる構造(エラーコード数値でもエラーコード文字列でも)を返す必要がある。
				errnoは上位でhitすることをすることで処理でき、その処理が終わったら
					元のerrnoの次の行から再開する(back)か
					そのcatchしたところと同じ関数で再送する(ret)か
					errnoの起こった行を再送する(rtry)か
					プロセスをキルする(die)
				必要がある。
			?<<
		@end

		ret 0 # return。
	@end

	int moreFunction$ls args ag @private # プロパティ構文は関数定義、宣言でも同様。
	@begin
		int tmp <- @sys:getarg ag, 0 # こうなるのかなぁ・・・？わからん。
		int tmp2 <- @sys:getarg ag, 1

		tmp <- tmp ? tmp2 # <-は代入記号
		tmp2 <- tmp ? tmp2 # ?はXOR演算子
		tmp <- tmp ? tmp2

		ret tmp, tmp2 # 複数返り値をどう処理するかなぁ。要検討。
	@end
@end
