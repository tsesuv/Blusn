' intro.@
' これでコメント。
"sysbio.@h" include ' sysbioはSYStem Basic Input/Output

intro mdl ' Javaのクラス的なのを採用
@begin
	[args def] main def @public
	@begin
		' 動的型付け言語。

		demo def @public <- 32
		' mdl内変数ではpublicを省略時はprivate。

		"Hello, world!", newl @sys:txout
		demo, newl @sys:txout

		demo2 def <- 16
		List$ls def <- [demo, demo2] @intro:moreFunction ' リストは変数に$をつけた後にlsと指定する。これはプロパティ構文という構文である。

		i def <- 0, k def <- 0; i++ , k++; for < 10 , < 5 ' これなら二重ループ。iが速く動き、iが条件を満たしたらkが動いてiが初期値に戻る。
		@begin
			"i: ", i, newl, "k: ", k, newl @sys:txout
		@end

		s1 def str <- @sys:txin
		@sys:txin.fail if ' @xx:yy.zzはメンバ関数。
		@begin
			"Invalid input", newl @sys:txout ' ちなみに@sys:txout.noflushにするとバッファフラッシュをしないでおいておくこともできる。デフォルトは呼び出すとフラッシュされるようになっている。
			"ERROR_INPUT_STR_INVALID" errno
			;;;
				errnoはretと排他の関係にある構文で、他言語でいう例外処理的な扱いになる。
				errnoは上位でキャッチできる構造(エラーコード数値でもエラーコード文字列でも)を返す必要がある。
				errnoは上位でhitすることをすることで処理でき、その処理が終わったら
					元のerrnoの次の行から再開する(back)か
					そのcatchしたところと同じ関数で再送する(ret)か
					errnoの起こった行を再送する(rtry)か
					プロセスをキルする(die)
				必要がある。
			;;;
		@end

		0 ret ' return。
	@end

	[args def] moreFunction$ls def @private ' プロパティ構文は関数定義、宣言でも同様。
	@begin
		tmp def <- [args, 0] @sys:getarg ' こうなるのかなぁ・・・？わからん。
		tmp2 def <- [args, 1] @sys:getarg
		tmp <- tmp + tmp2 ' <-は代入記号
		tmp2 <- tmp - tmp2
		tmp <- tmp - tmp2

		[tmp, tmp2] ret ' 複数返り値をどう処理するかなぁ。要検討。
	@end
@end
